"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateAnchorAndAngleByValue = exports.clearMarks = exports.clearValueLabel = exports.addValueText = exports.addText = exports.getLabelCoordsByValue = exports.addMark = exports.addMarkValue = exports.addMarker = exports.mapMark = exports.addArcMarks = exports.setupMarks = exports.setupValueLabel = exports.setupLabels = void 0;
var utils = __importStar(require("./utils"));
var constants_1 = __importDefault(require("../constants"));
var GaugeComponentProps_1 = require("../types/GaugeComponentProps");
var arc_1 = require("./arc");
var setupLabels = function (gauge) {
    (0, exports.setupValueLabel)(gauge);
    (0, exports.setupMarks)(gauge);
};
exports.setupLabels = setupLabels;
var setupValueLabel = function (gauge) {
    var _a;
    var labels = gauge.props.labels;
    if (!((_a = labels === null || labels === void 0 ? void 0 : labels.valueLabel) === null || _a === void 0 ? void 0 : _a.hide))
        (0, exports.addValueText)(gauge);
};
exports.setupValueLabel = setupValueLabel;
var setupMarks = function (gauge) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    var labels = gauge.props.labels;
    var minValue = gauge.props.minValue;
    var maxValue = gauge.props.maxValue;
    if (constants_1.default.debugMarkersRadius) {
        for (var index = 0; index < maxValue; index++) {
            var indexMark = (0, exports.mapMark)(index, gauge);
            (0, exports.addMark)(indexMark, gauge);
        }
    }
    else if (!((_a = labels.markLabel) === null || _a === void 0 ? void 0 : _a.hideMinMax)) {
        var alreadyHaveMinValueMark = (_c = (_b = labels.markLabel) === null || _b === void 0 ? void 0 : _b.marks) === null || _c === void 0 ? void 0 : _c.some(function (mark) { return mark.value == minValue; });
        if (!alreadyHaveMinValueMark) {
            //Add min value mark
            var minValueMark = (0, exports.mapMark)(minValue, gauge);
            (0, exports.addMark)(minValueMark, gauge);
        }
        var alreadyHaveMaxValueMark = (_e = (_d = labels.markLabel) === null || _d === void 0 ? void 0 : _d.marks) === null || _e === void 0 ? void 0 : _e.some(function (mark) { return mark.value == maxValue; });
        if (!alreadyHaveMaxValueMark) {
            // //Add max value mark
            var maxValueMark = (0, exports.mapMark)(maxValue, gauge);
            (0, exports.addMark)(maxValueMark, gauge);
        }
    }
    if (((_g = (_f = labels.markLabel) === null || _f === void 0 ? void 0 : _f.marks) === null || _g === void 0 ? void 0 : _g.length) > 0) {
        (_j = (_h = labels.markLabel) === null || _h === void 0 ? void 0 : _h.marks) === null || _j === void 0 ? void 0 : _j.forEach(function (mark) {
            (0, exports.addMark)(mark, gauge);
        });
    }
    (0, exports.addArcMarks)(gauge);
};
exports.setupMarks = setupMarks;
var addArcMarks = function (gauge) {
    var _a;
    var arc = gauge.props.arc;
    (_a = gauge.arcData.current) === null || _a === void 0 ? void 0 : _a.map(function (subArc) {
        if (subArc.showMark)
            return subArc.limit;
    }).forEach(function (markValue) {
        if (markValue)
            (0, exports.addMark)((0, exports.mapMark)(markValue, gauge), gauge);
    });
};
exports.addArcMarks = addArcMarks;
var mapMark = function (value, gauge) {
    var markLabel = gauge.props.labels.markLabel;
    return {
        value: value,
        valueConfig: markLabel === null || markLabel === void 0 ? void 0 : markLabel.valueConfig,
        markerConfig: markLabel === null || markLabel === void 0 ? void 0 : markLabel.markerConfig
    };
};
exports.mapMark = mapMark;
var addMarker = function (mark, gauge) {
    var _a, _b, _c, _d, _e, _f;
    var labels = gauge.props.labels;
    var _g = (0, exports.calculateAnchorAndAngleByValue)(mark === null || mark === void 0 ? void 0 : mark.value, gauge), markAnchor = _g.markAnchor, angle = _g.angle;
    var coords = (0, exports.getLabelCoordsByValue)(mark === null || mark === void 0 ? void 0 : mark.value, gauge, undefined);
    var char = ((_a = mark.markerConfig) === null || _a === void 0 ? void 0 : _a.char) || ((_c = (_b = labels === null || labels === void 0 ? void 0 : labels.markLabel) === null || _b === void 0 ? void 0 : _b.markerConfig) === null || _c === void 0 ? void 0 : _c.char);
    var charStyle = ((_d = mark.markerConfig) === null || _d === void 0 ? void 0 : _d.style) || (((_f = (_e = labels === null || labels === void 0 ? void 0 : labels.markLabel) === null || _e === void 0 ? void 0 : _e.markerConfig) === null || _f === void 0 ? void 0 : _f.style) || {});
    charStyle = __assign({}, charStyle);
    charStyle.textAnchor = markAnchor;
    (0, exports.addText)(char, coords.x, coords.y, gauge, charStyle, constants_1.default.markerClassname, angle);
};
exports.addMarker = addMarker;
var addMarkValue = function (mark, gauge) {
    var _a, _b, _c, _d, _e, _f, _g;
    var _h = gauge.props, labels = _h.labels, value = _h.value;
    var arc = gauge.props.arc;
    var arcWidth = arc.width;
    var markValue = mark === null || mark === void 0 ? void 0 : mark.value;
    var _j = (0, exports.calculateAnchorAndAngleByValue)(markValue, gauge), markAnchor = _j.markAnchor, angle = _j.angle;
    var centerToArcLengthSubtract = 27 - arcWidth * 10;
    var isInner = ((_a = labels === null || labels === void 0 ? void 0 : labels.markLabel) === null || _a === void 0 ? void 0 : _a.type) == "inner";
    if (!isInner)
        centerToArcLengthSubtract = arcWidth * 10 - 20;
    var coords = (0, exports.getLabelCoordsByValue)(markValue, gauge, centerToArcLengthSubtract);
    var markValueStyle = ((_b = mark.valueConfig) === null || _b === void 0 ? void 0 : _b.style) || (((_d = (_c = labels === null || labels === void 0 ? void 0 : labels.markLabel) === null || _c === void 0 ? void 0 : _c.valueConfig) === null || _d === void 0 ? void 0 : _d.style) || {});
    markValueStyle = __assign({}, markValueStyle);
    var text = '';
    if ((_f = (_e = labels === null || labels === void 0 ? void 0 : labels.markLabel) === null || _e === void 0 ? void 0 : _e.valueConfig) === null || _f === void 0 ? void 0 : _f.formatTextValue) {
        text = labels.markLabel.valueConfig.formatTextValue(utils.floatingNumber(markValue));
    }
    else if (gauge.props.minValue === 0 && gauge.props.maxValue === 100) {
        text = utils.floatingNumber(markValue).toString();
        text += "%";
    }
    else {
        text = utils.floatingNumber(markValue).toString();
    }
    //This is a position correction for the text being too far away from the marker
    if (((_g = labels === null || labels === void 0 ? void 0 : labels.markLabel) === null || _g === void 0 ? void 0 : _g.type) == "inner") {
        if (markAnchor === "end")
            coords.x += 10;
        if (markAnchor === "start")
            coords.x -= 10;
        if (markAnchor === "middle")
            coords.y -= 15;
    }
    else {
        // if(markAnchor === "end") coords.x -= 10;
        // if(markAnchor === "start") coords.x += 10;
    }
    if (markAnchor === "middle") {
        coords.y += 8;
    }
    else {
        coords.y += 3;
    }
    markValueStyle.textAnchor = markAnchor;
    (0, exports.addText)(text, coords.x, coords.y, gauge, markValueStyle, constants_1.default.markValueClassname);
};
exports.addMarkValue = addMarkValue;
var addMark = function (mark, gauge) {
    var _a = gauge.props, minValue = _a.minValue, maxValue = _a.maxValue, labels = _a.labels, arc = _a.arc;
    (0, exports.addMarker)(mark, gauge);
    if (!constants_1.default.debugMarkersRadius) {
        (0, exports.addMarkValue)(mark, gauge);
    }
};
exports.addMark = addMark;
var getLabelCoordsByValue = function (value, gauge, centerToArcLengthSubtract) {
    var _a;
    if (centerToArcLengthSubtract === void 0) { centerToArcLengthSubtract = 0; }
    var labels = gauge.props.labels;
    var minValue = gauge.props.minValue;
    var maxValue = gauge.props.maxValue;
    var type = (_a = labels.markLabel) === null || _a === void 0 ? void 0 : _a.type;
    var _b = (0, arc_1.getCoordByValue)(value, gauge, type, centerToArcLengthSubtract, 0.93), x = _b.x, y = _b.y;
    var percent = utils.calculatePercentage(minValue, maxValue, value);
    //This corrects labels in the cener being too close from the arc
    var isValueBetweenCenter = percent > constants_1.default.rangeBetweenCenteredMarkValueLabel[0] &&
        percent < constants_1.default.rangeBetweenCenteredMarkValueLabel[1];
    if (isValueBetweenCenter) {
        var isInner = type == "inner";
        y += isInner ? 8 : -1;
    }
    if (gauge.props.type == GaugeComponentProps_1.GaugeType.Radial) {
        y += 3;
    }
    return { x: x, y: y };
};
exports.getLabelCoordsByValue = getLabelCoordsByValue;
var addText = function (html, x, y, gauge, style, className, rotate) {
    if (rotate === void 0) { rotate = 0; }
    var div = gauge.g.current
        .append("g")
        .attr("class", className)
        .attr("transform", "translate(".concat(x, ", ").concat(y, ")"))
        .append("text")
        .text(html); // use html() instead of text()
    applyTextStyles(div, style);
    div.attr("transform", "rotate(".concat(rotate, ")"));
};
exports.addText = addText;
var applyTextStyles = function (div, style) {
    //Apply default styles
    Object.entries(style).forEach(function (_a) {
        var key = _a[0], value = _a[1];
        return div.style(utils.camelCaseToKebabCase(key), value);
    });
    //Apply custom styles
    if (style != undefined)
        Object.entries(style).forEach(function (_a) {
            var key = _a[0], value = _a[1];
            return div.style(utils.camelCaseToKebabCase(key), value);
        });
};
//Adds text undeneath the graft to display which percentage is the current one
var addValueText = function (gauge) {
    var _a, _b, _c;
    var value = gauge.props.value;
    var valueLabel = (_a = gauge.props.labels) === null || _a === void 0 ? void 0 : _a.valueLabel;
    var textPadding = 20;
    var text = '';
    if (valueLabel.formatTextValue) {
        text = valueLabel.formatTextValue(utils.floatingNumber(value));
    }
    else if (gauge.props.minValue === 0 && gauge.props.maxValue === 100) {
        text = utils.floatingNumber(value).toString();
        text += "%";
    }
    else {
        text = utils.floatingNumber(value).toString();
    }
    var maxLengthBeforeComputation = 4;
    var textLength = (text === null || text === void 0 ? void 0 : text.length) || 0;
    var fontRatio = textLength > maxLengthBeforeComputation ? maxLengthBeforeComputation / textLength * 1.5 : 1; // Compute the font size ratio
    var valueFontSize = (_b = valueLabel === null || valueLabel === void 0 ? void 0 : valueLabel.style) === null || _b === void 0 ? void 0 : _b.fontSize;
    var valueTextStyle = __assign({}, valueLabel.style);
    var x = gauge.dimensions.current.outerRadius;
    var y = 0;
    valueTextStyle.textAnchor = "middle";
    if (gauge.props.type == GaugeComponentProps_1.GaugeType.Semicircle) {
        y = gauge.dimensions.current.outerRadius / 1.5 + textPadding;
    }
    else if (gauge.props.type == GaugeComponentProps_1.GaugeType.Radial) {
        y = gauge.dimensions.current.outerRadius * 1.45 + textPadding;
    }
    else if (gauge.props.type == GaugeComponentProps_1.GaugeType.Grafana) {
        y = gauge.dimensions.current.outerRadius * 1.0 + textPadding;
    }
    //if(gauge.props.pointer.type == PointerType.Arrow){
    //  y = gauge.dimensions.current.outerRadius * 0.79 + textPadding;
    //}
    var widthFactor = gauge.props.type == GaugeComponentProps_1.GaugeType.Radial ? 0.003 : 0.003;
    fontRatio = gauge.dimensions.current.width * widthFactor * fontRatio;
    var fontSizeNumber = parseInt(valueFontSize, 10) * fontRatio;
    valueTextStyle.fontSize = fontSizeNumber + "px";
    if (valueLabel.matchColorWithArc)
        valueTextStyle.fill = ((_c = (0, arc_1.getArcDataByValue)(value, gauge)) === null || _c === void 0 ? void 0 : _c.color) || "white";
    (0, exports.addText)(text, x, y, gauge, valueTextStyle, constants_1.default.valueLabelClassname);
};
exports.addValueText = addValueText;
var clearValueLabel = function (gauge) { return gauge.g.current.selectAll(".".concat(constants_1.default.valueLabelClassname)).remove(); };
exports.clearValueLabel = clearValueLabel;
var clearMarks = function (gauge) {
    gauge.g.current.selectAll(".".concat(constants_1.default.markerClassname)).remove();
    gauge.g.current.selectAll(".".concat(constants_1.default.markValueClassname)).remove();
};
exports.clearMarks = clearMarks;
var calculateAnchorAndAngleByValue = function (value, gauge) {
    var _a;
    var _b, _c;
    var minValue = gauge.props.minValue;
    var maxValue = gauge.props.maxValue;
    var valuePercentage = utils.calculatePercentage(minValue, maxValue, value);
    var gaugeTypesAngles = (_a = {},
        _a[GaugeComponentProps_1.GaugeType.Grafana] = {
            startAngle: -20,
            endAngle: 220
        },
        _a[GaugeComponentProps_1.GaugeType.Semicircle] = {
            startAngle: 0,
            endAngle: 180
        },
        _a[GaugeComponentProps_1.GaugeType.Radial] = {
            startAngle: -42,
            endAngle: 266
        },
        _a);
    var _d = gaugeTypesAngles[gauge.props.type], startAngle = _d.startAngle, endAngle = _d.endAngle;
    var angle = startAngle + (valuePercentage * 100) * endAngle / 100;
    var halfInPercentage = utils.calculatePercentage(minValue, maxValue, (maxValue / 2));
    var halfPercentage = halfInPercentage;
    var isValueLessThanHalf = valuePercentage < halfPercentage;
    //Values between 40% and 60% are aligned in the middle
    var isValueBetweenTolerance = valuePercentage > constants_1.default.rangeBetweenCenteredMarkValueLabel[0] &&
        valuePercentage < constants_1.default.rangeBetweenCenteredMarkValueLabel[1];
    var markAnchor = '';
    var isInner = ((_c = (_b = gauge.props.labels) === null || _b === void 0 ? void 0 : _b.markLabel) === null || _c === void 0 ? void 0 : _c.type) == "inner";
    if (isValueBetweenTolerance) {
        markAnchor = "middle";
    }
    else if (isValueLessThanHalf) {
        markAnchor = isInner ? "start" : "end";
    }
    else {
        markAnchor = isInner ? "end" : "start";
    }
    if (valuePercentage > 0.50)
        angle = angle - 180;
    return { markAnchor: markAnchor, angle: angle };
};
exports.calculateAnchorAndAngleByValue = calculateAnchorAndAngleByValue;
